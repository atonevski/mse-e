// Generated by CoffeeScript 1.10.0
var D_NEW_FMT, fs, http, https, notifyOnlineStatus, path, vue, xlsx;

https = require('https');

http = require('http');

xlsx = require('xlsx');

fs = require('fs');

path = require('path');

D_NEW_FMT = new Date(Date.parse('2018-08-03'));

notifyOnlineStatus = function(e) {
  return new Notification('Online status', {
    body: navigator.onLine ? 'You are online!' : 'You are offline now!',
    icon: navigator.onLine ? '../img/net-on.png' : '../img/net-off.png'
  });
};

addEventListener('load', notifyOnlineStatus, false);

addEventListener('offline', notifyOnlineStatus, false);

addEventListener('online', notifyOnlineStatus, false);

vue = new Vue({
  el: '#app',
  data: {
    date: null,
    buf: null,
    wb: null,
    trns: [],
    bonds: [],
    totals: {},
    change: {}
  },
  methods: {
    toYMD: function(d) {
      var sep;
      if (!(d instanceof Date)) {
        d = new Date(Date.parse(d));
      }
      sep = arguments.length > 1 ? arguments[1] : '';
      return (new Date(d - d.getTimezoneOffset() * 1000 * 60)).toISOString().slice(0, 10).split('-').join(sep);
    },
    toDMY: function(d) {
      var sep;
      if (!(d instanceof Date)) {
        d = new Date(Date.parse(d));
      }
      sep = arguments.length > 1 ? arguments[1] : '';
      return (new Date(d - d.getTimezoneOffset() * 1000 * 60)).toISOString().slice(0, 10).split('-').reverse().join(sep);
    },
    daysBefore: function(d, n) {
      return new Date(d.getTime() - n * 24 * 60 * 60 * 1000);
    },
    daysAfter: function(d, n) {
      return new Date(d.getTime() + n * 24 * 60 * 60 * 1000);
    },
    startEndOfMonth: function(d) {
      var end, start;
      start = new Date(d.getFullYear(), d.getMonth(), 1);
      end = new Date(d.getFullYear(), d.getMonth() + 1, 0);
      return [start, end];
    },
    startEndOfWeek: function(d) {
      if (d.getDay() === 0) {
        return [this.daysBefore(d, 6), d];
      } else {
        return [this.daysBefore(d, d.getDay() - 1), this.daysAfter(d, 7 - d.getDay())];
      }
    },
    weekDays: function() {
      if (arguments.length > 0 && arguments[0] === 'en') {
        return ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"];
      } else if (arguments.length > 0 && arguments[0] === 'mk') {
        return ["недела", "понеделник", "вторник", "среда", "четврток", "петок", "сабота"];
      } else {
        return ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"];
      }
    },
    mseUrl: function(d) {
      if (arguments.length > 1) {
        return "https://www.mse.mk/Repository/Reports/MK/ReportMK_1_" + ((this.toYMD(d)) + "_" + (this.toYMD(d)) + ".xls");
      } else {
        return "https://www.mse.mk/Repository/Reports/MK_New/" + ((this.toDMY(d, '.')) + "mk.xls");
      }
    },
    prevValidDate: function(d) {
      switch (d.getDay()) {
        case 0:
          return this.daysBefore(d, 2);
        case 1:
          return this.daysBefore(d, 3);
        default:
          return this.daysBefore(d, 1);
      }
    },
    loadLast: function() {
      var url;
      this.date = arguments.length > 0 ? arguments[0] : (new Date(Date.now())).getHours() < 14 ? this.prevValidDate(new Date()) : new Date();
      url = this.date < D_NEW_FMT ? this.mseUrl(this.date, true) : this.mseUrl(this.date);
      console.log("Trying to load: " + (this.toYMD(this.date, '-')));
      return https.get(url, (function(_this) {
        return function(res) {
          var body;
          if (res.statusCode === 404) {
            _this.loadLast(_this.prevValidDate(_this.date));
            return null;
          }
          body = '';
          res.setEncoding('binary');
          res.on('data', function(d) {
            return body += d;
          });
          return res.on('end', function() {
            _this.buf = body;
            _this.wb = xlsx.read(_this.buf, {
              type: 'binary'
            });
            console.log("successfully loaded report for " + (_this.toYMD(_this.date, '-')));
            return _this.processReport();
          });
        };
      })(this));
    },
    processReport: function() {
      var Ar, Br, Cr, Hr, Ir, Jr, bonds, change, i, inbonds, r, rcount, ref, totals, trns, ws;
      this.trns = [];
      ws = this.wb.Sheets.Sheet1;
      rcount = ws['!rows'].length;
      inbonds = false;
      trns = [];
      bonds = [];
      change = {
        win: 0,
        loss: 0,
        even: 0
      };
      totals = {
        trns: 0,
        bonds: 0
      };
      for (r = i = 4, ref = rcount; 4 <= ref ? i <= ref : i >= ref; r = 4 <= ref ? ++i : --i) {
        Ar = "A" + r;
        Br = "B" + r;
        Cr = "C" + r;
        Hr = "H" + r;
        Ir = "I" + r;
        Jr = "J" + r;
        if (ws[Ar].v.includes("обврзници")) {
          inbonds = true;
          continue;
        }
        if (inbonds && (ws[Jr] == null)) {
          inbonds = false;
        }
        if ((ws[Ir] == null) || (ws[Jr] == null)) {
          continue;
        }
        if (ws[Ir].v <= 0) {
          continue;
        }
        if (!inbonds) {
          trns.push({
            company: ws[Ar].v,
            raise: ws[Cr] != null ? ws[Cr].v : null,
            turnover: ws[Jr].v * 1000,
            shares: ws[Ir].v,
            price: ws[Br] == null ? ws[Hr].v : ws[Br].v
          });
          switch (false) {
            case !(ws[Cr] == null):
              break;
            case !(ws[Cr].v < 0):
              change.loss++;
              break;
            case ws[Cr].v !== 0:
              change.even++;
              break;
            case !(ws[Cr].v > 0):
              change.win++;
          }
          totals.trns += ws[Jr].v * 1000;
        } else {
          bonds.push({
            title: ws[Ar].v,
            qty: ws[Ir].v,
            turnover: ws[Jr].v * 1000,
            price: ws[Br].v
          });
          totals.bonds += ws[Jr].v * 1000;
        }
      }
      console.log(trns);
      this.trns = trns;
      this.bonds = this.totals = totals;
      return this.change = change;
    }
  },
  created: function() {
    return this.loadLast();
  },
  filters: {
    number: function(v) {
      if (typeof v === 'undefined') {
        return v;
      }
      if (v !== null && typeof v.toLocaleString === 'function') {
        return v.toLocaleString();
      } else {
        return v;
      }
    },
    toDMY: function(d, s) {
      if (!(d instanceof Date)) {
        d = new Date(Date.parse(d));
      }
      if (!s) {
        s = '';
      }
      return (new Date(d - d.getTimezoneOffset() * 1000 * 60)).toISOString().slice(0, 10).split('-').reverse().join(s);
    }
  }
});
