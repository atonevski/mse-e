// Generated by CoffeeScript 1.10.0
var D_NEW_FMT, fs, http, https, maxDateOpt, notifyOnlineStatus, opts, path, q, vue, xlsx;

https = require('https');

http = require('http');

xlsx = require('xlsx');

fs = require('fs');

path = require('path');

q = require('q');

D_NEW_FMT = new Date(Date.parse('2018-08-03'));

notifyOnlineStatus = function(e) {
  return new Notification('Online status', {
    body: navigator.onLine ? 'You are online!' : 'You are offline now!',
    icon: navigator.onLine ? '../img/net-on.png' : '../img/net-off.png'
  });
};

addEventListener('load', notifyOnlineStatus, false);

addEventListener('offline', notifyOnlineStatus, false);

addEventListener('online', notifyOnlineStatus, false);

maxDateOpt = function() {
  var d;
  d = new Date();
  switch (d.getDay()) {
    case 0:
      return new Date(d.getTime() - 2 * 24 * 60 * 60 * 1000);
    case 6:
      return new Date(d.getTime() - 1 * 24 * 60 * 60 * 1000);
    default:
      return d;
  }
};

opts = {
  format: 'YYYY-MM-DD',
  minDate: new Date('2003-01-01'),
  maxDate: maxDateOpt(),
  daysOfWeekDisabled: [0, 6],
  locale: moment.locale('en', {
    week: {
      dow: 1
    }
  })
};

$('#pickdate').datetimepicker(opts).on('dp.change', function() {
  var d;
  console.log("date changed");
  d = new Date($('#pickdate').data('date'));
  if (d != null) {
    vue.setDates(d);
  }
  return document.getElementById('select-month-reminder').style.display = 'none';
});

vue = new Vue({
  el: '#app',
  data: {
    date: null,
    from: null,
    to: null,
    wbs: [],
    companies: {},
    bonds: {},
    change: {
      win: 0,
      loss: 0,
      even: 0
    },
    totals: {
      companies: 0,
      bonds: 0
    },
    monthNames: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "Nobember", "December"]
  },
  methods: {
    setDates: function(d) {
      var last, today;
      if (d == null) {
        return;
      }
      this.date = d;
      today = new Date();
      this.from = new Date(d.getFullYear(), d.getMonth(), 1);
      last = new Date(d.getFullYear(), d.getMonth() + 1, 0);
      this.to = last > today ? today : last;
      return this.loadWeekly();
    },
    dmyToDate: function(s) {
      return new Date(s.split('.').reverse().join('-'));
    },
    toYMD: function(d) {
      var sep;
      if (!(d instanceof Date)) {
        d = new Date(Date.parse(d));
      }
      sep = arguments.length > 1 ? arguments[1] : '';
      return (new Date(d - d.getTimezoneOffset() * 1000 * 60)).toISOString().slice(0, 10).split('-').join(sep);
    },
    toDMY: function(d) {
      var sep;
      if (!(d instanceof Date)) {
        d = new Date(Date.parse(d));
      }
      sep = arguments.length > 1 ? arguments[1] : '';
      return (new Date(d - d.getTimezoneOffset() * 1000 * 60)).toISOString().slice(0, 10).split('-').reverse().join(sep);
    },
    mseUrl: function(d) {
      if (arguments.length > 1) {
        return "https://www.mse.mk/Repository/Reports/MK/ReportMK_1_" + ((this.toYMD(d)) + "_" + (this.toYMD(d)) + ".xls");
      } else {
        return "https://www.mse.mk/Repository/Reports/MK_New/" + ((this.toDMY(d, '.')) + "mk.xls");
      }
    },
    daysBefore: function(d, n) {
      return new Date(d.getTime() - n * 24 * 60 * 60 * 1000);
    },
    daysAfter: function(d, n) {
      return new Date(d.getTime() + n * 24 * 60 * 60 * 1000);
    },
    mseUrl: function(d) {
      if (arguments.length > 1) {
        return "https://www.mse.mk/Repository/Reports/MK/ReportMK_1_" + ((this.toYMD(d)) + "_" + (this.toYMD(d)) + ".xls");
      } else {
        return "https://www.mse.mk/Repository/Reports/MK_New/" + ((this.toDMY(d, '.')) + "mk.xls");
      }
    },
    parseXls: function(data) {
      return xlsx.read(data, {
        type: 'binary'
      });
    },
    processWbs: function() {
      var Ar, Br, Cr, Hr, Ir, Jr, bonds, change, companies, date, i, inbonds, j, len, r, rcount, ref, ref1, totals, wb, ws;
      companies = {};
      bonds = {};
      change = {
        win: 0,
        loss: 0,
        even: 0
      };
      totals = {
        companies: 0,
        bonds: 0
      };
      ref = this.wbs;
      for (i = 0, len = ref.length; i < len; i++) {
        wb = ref[i];
        ws = wb.Sheets.Sheet1;
        rcount = ws['!rows'].length;
        inbonds = false;
        date = this.dmyToDate(ws['A2'].v.slice(ws['A2'].v.length - 10));
        console.log(date);
        for (r = j = 4, ref1 = rcount; 4 <= ref1 ? j <= ref1 : j >= ref1; r = 4 <= ref1 ? ++j : --j) {
          Ar = "A" + r;
          Br = "B" + r;
          Cr = "C" + r;
          Hr = "H" + r;
          Ir = "I" + r;
          Jr = "J" + r;
          if (ws[Ar].v.includes("обврзници")) {
            inbonds = true;
            continue;
          }
          if (inbonds && (ws[Jr] == null)) {
            inbonds = false;
          }
          if ((ws[Ir] == null) || (ws[Jr] == null)) {
            continue;
          }
          if (ws[Ir].v <= 0) {
            continue;
          }
          if (!inbonds) {
            if (companies[ws[Ar].v] == null) {
              companies[ws[Ar].v] = [];
            }
            companies[ws[Ar].v].push({
              date: date,
              raise: ws[Cr] != null ? ws[Cr].v : null,
              turnover: ws[Jr].v * 1000,
              shares: ws[Ir].v,
              price: ws[Br] == null ? ws[Hr].v : ws[Br].v
            });
            switch (false) {
              case !(ws[Cr] == null):
                break;
              case !(ws[Cr].v < 0):
                change.loss++;
                break;
              case ws[Cr].v !== 0:
                change.even++;
                break;
              case !(ws[Cr].v > 0):
                change.win++;
            }
            totals.companies += ws[Jr].v * 1000;
          } else {
            if (bonds[ws[Ar].v] == null) {
              bonds[ws[Ar].v] = [];
            }
            bonds[ws[Ar].v].push({
              date: date,
              qty: ws[Ir].v,
              turnover: ws[Jr].v * 1000,
              price: ws[Br].v
            });
            totals.bonds += ws[Jr].v * 1000;
          }
        }
      }
      this.companies = companies;
      this.bonds = bonds;
      this.change = change;
      this.totals = totals;
      return console.log(this.companies);
    },
    loadWeekly: function() {
      var all, day, promises, wbs;
      this.companies = {};
      this.bonds = {};
      this.change = {
        win: 0,
        loss: 0,
        even: 0
      };
      this.totals = {
        companies: 0,
        bonds: 0
      };
      day = this.from;
      promises = [];
      while (day <= this.to) {
        (function(_this) {
          return (function(day) {
            var p;
            p = q.Promise(function(resolve, reject) {
              var url;
              url = day < D_NEW_FMT ? _this.mseUrl(day, true) : _this.mseUrl(day);
              https.get(url, function(res) {
                var body;
                res.setEncoding('binary');
                if (res.statusCode !== 200) {
                  reject(new Error("Failed for date: " + day));
                  return null;
                }
                body = [];
                res.on('data', function(d) {
                  return body.push(d);
                });
                res.on('end', function() {
                  return resolve(_this.parseXls(body.join('')));
                });
                res.on('error', function(e) {
                  return reject(e);
                });
                return null;
              });
              return null;
            });
            p = p["catch"](function(e) {
              return null;
            });
            return promises.push(p);
          });
        })(this)(day);
        day = this.daysAfter(day, 1);
      }
      all = q.all(promises);
      wbs = [];
      return all.then((function(_this) {
        return function(wa) {
          var i, len, wb;
          for (i = 0, len = wa.length; i < len; i++) {
            wb = wa[i];
            if (wb !== null) {
              wbs.push(wb);
            }
          }
          _this.wbs = wbs;
          return _this.processWbs();
        };
      })(this));
    }
  },
  filters: {
    number: function(v) {
      if (typeof v === 'undefined') {
        return v;
      }
      if (v !== null && typeof v.toLocaleString === 'function') {
        return v.toLocaleString();
      } else {
        return v;
      }
    },
    toDMY: function(d, s) {
      if (!d) {
        return;
      }
      if (!(d instanceof Date)) {
        d = new Date(Date.parse(d));
      }
      if (!s) {
        s = '';
      }
      return (new Date(d - d.getTimezoneOffset() * 1000 * 60)).toISOString().slice(0, 10).split('-').reverse().join(s);
    }
  }
});
